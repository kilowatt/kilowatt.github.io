<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>

<!-- ======================================================================= -->
<script src="http://www.google.com/jsapi" type="text/javascript"></script>
<script type="text/javascript">google.load("jquery", "1.3.2");</script>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script id="MathJax-script" async
          src="https://cdn.jsdelivr.net/npm/mathjax@3.0.1/es5/tex-mml-chtml.js">
  </script>
<style type="text/css">
    table {
        margin-bottom: 5px;
        margin-top: 5px;
    }
    body {
        font-family: "Titillium Web", "HelveticaNeue-Light", "Helvetica Neue Light", "Helvetica Neue", Helvetica, Arial, "Lucida Grande", sans-serif;
        font-weight: 300;
        font-size: 18px;
        margin-left: auto;
        margin-right: auto;
        width: 60%;
    }

    h1 {
        font-weight: 300;
    }

    .disclaimerbox {
        background-color: #eee;
        border: 1px solid #eeeeee;
        border-radius: 10px;
        -moz-border-radius: 10px;
        -webkit-border-radius: 10px;
        padding: 20px;
    }

    video.header-vid {
        height: 140px;
        border: 1px solid black;
        border-radius: 10px;
        -moz-border-radius: 10px;
        -webkit-border-radius: 10px;
    }

    img {
        width: 100%
    }

    img.header-img {
        height: 140px;
        border: 1px solid black;
        border-radius: 10px;
        -moz-border-radius: 10px;
        -webkit-border-radius: 10px;
    }

    img.rounded {
        border: 1px solid #eeeeee;
        border-radius: 10px;
        -moz-border-radius: 10px;
        -webkit-border-radius: 10px;
    }

    a:link, a:visited {
        color: #1367a7;
        text-decoration: none;
    }

    a:hover {
        color: #208799;
    }

    td.dl-link {
        height: 160px;
        text-align: center;
        font-size: 22px;
    }

    .layered-paper-big { /* modified from: http://css-tricks.com/snippets/css/layered-paper/ */
        box-shadow: 0px 0px 1px 1px rgba(0, 0, 0, 0.35), /* The top layer shadow */ 5px 5px 0 0px #fff, /* The second layer */ 5px 5px 1px 1px rgba(0, 0, 0, 0.35), /* The second layer shadow */ 10px 10px 0 0px #fff, /* The third layer */ 10px 10px 1px 1px rgba(0, 0, 0, 0.35), /* The third layer shadow */ 15px 15px 0 0px #fff, /* The fourth layer */ 15px 15px 1px 1px rgba(0, 0, 0, 0.35), /* The fourth layer shadow */ 20px 20px 0 0px #fff, /* The fifth layer */ 20px 20px 1px 1px rgba(0, 0, 0, 0.35), /* The fifth layer shadow */ 25px 25px 0 0px #fff, /* The fifth layer */ 25px 25px 1px 1px rgba(0, 0, 0, 0.35); /* The fifth layer shadow */
        margin-left: 10px;
        margin-right: 45px;
    }


    .layered-paper { /* modified from: http://css-tricks.com/snippets/css/layered-paper/ */
        box-shadow: 0px 0px 1px 1px rgba(0, 0, 0, 0.35), /* The top layer shadow */ 5px 5px 0 0px #fff, /* The second layer */ 5px 5px 1px 1px rgba(0, 0, 0, 0.35), /* The second layer shadow */ 10px 10px 0 0px #fff, /* The third layer */ 10px 10px 1px 1px rgba(0, 0, 0, 0.35); /* The third layer shadow */
        margin-top: 5px;
        margin-left: 10px;
        margin-right: 30px;
        margin-bottom: 5px;
    }

    .vert-cent {
        position: relative;
        top: 50%;
        transform: translateY(-50%);
    }

    hr {
        border: 0;
        height: 1px;
        background-image: linear-gradient(to right, rgba(0, 0, 0, 0), rgba(0, 0, 0, 0.75), rgba(0, 0, 0, 0));
    }


    #authors td {
        padding-bottom: 5px;
        padding-top: 30px;
    }
</style>


<head>
    <title>Images of the Russian Empire:Colorizing the Prokudin-Gorskii photo collection</title>
    <meta property="og:title" content="Images of the Russian Empire:Colorizing the Prokudin-Gorskii photo collection"/>
</head>

<body>
<br>
<center>
    <span style="font-size:36px">Images of the Russian Empire:Colorizing the Prokudin-Gorskii photo collection</span>

    <br>
    <br>

        <!-- <span style="font-size:24px">CVPR 2022</span> -->


    <br>
    <br>
    <table align=center>
        <tr>
            <span style="font-size:24px"><a >Bill Zheng</a><sup>1</sup></span> &nbsp;
            
        </tr><br>
        <tr>
            <span style="font-size:16px"><a>SID:3036580418</a></span> &nbsp;
        </tr><br>
        <tr>
   </tr>
    </table>


<!--    <br><br><br>-->

<!--    <br><br>-->


    <table align=center>
        <tr>
            <td align=center>
                <center>
                    <span style="font-size:20px">
                        <sup>1</sup>UC Berkeley 
                    </span>
                </center>
            </td>
        </tr>
    </table>
<!--    <br>-->




</center>
<!--<left>    <span style="font-size:18px"><sup>*</sup>Equally contributed</span> </left>-->
<center><img src="sobel/icon.jpg" align="middle"></center>
<hr>

<table align=center>
    <center><h1>Overview</h1></center>
</table>

<a href="http://en.wikipedia.org/wiki/Prokudin-Gorskii">Sergei Mikhailovich Prokudin-Gorskii</a> (1863-1944) was an innovator: he traveled around the Russian Empire to record colored images by documenting the scenes in 3-colored channels and combining them together to create effects of color. While there have been many manual implementation of colorizing his images, this project implements methods that can algorithmically colorize the photos of his collection.
<br><br><br>

<hr>
<br>

<table align=center>
    <center><h1 id="model">Methods</h1></center>
</table>
<p>
There are two steps in recreating a colored image out of 3 channels: Image alignment and Color Restoration. In an image alignemet phase, we try to align the three channels together as close as possible, and we can reframe this as an optimization problem where we are optimizing this objective:
$$\mathrm{argmin}_{x,y} \; \mathcal{L}(\text{shift}(P, (x, y)),Q)$$
where \(P,Q\) are images (which are represented by a matrix) of dimension \( h \times w \), and \( P_{+x,+y} \) is the image \(P\) shifted by vector \( (x,y )\) (we would use np.roll to represent the shift).
I experimented on two objectives, the Sum of Squared Difference (SSD) and Normalized Cross Correlation (NCC), defined by 
$$SSD(P,Q)= ||P - Q ||_F ^2 $$ 
$$NCC(P,Q)= -\frac{\text{Sum}(P \odot Q)}{||P||_F ||Q||_F} $$
<p>SSD operates like a residual operator and we are trying to find the best shift to reduce the error magnitude, and NCC acts like dot product where we would like to find the vectors that have the smallest angles.</p>
For smaller images, we can run a naive algorithm, which is to iterate through a space \( [-15, 15]^2\) (or other pre-set values) for both the green and red channel on the blue channel for best alignment with the hope that the best alignment would most likely reside in that region. However this becomes impractical for larger images, as it is unlikely for the best alignment to occur within this set, and exhaustive search grows quadratically in runtime.
<p>In this case, I implemented pyramid search by recursively finding the best alignment for a downsized image, and then finding the best match that should be constrained only to a small region around the best match returned in the upscaled image to account for downscaling loss and potential distortion from anti-aliasing (I used \( [-1, 1]^2\) and it works well, as the search is pretty much like Binary Tree Search).</p>
</p><p>
In my implementation, I used blue channel as the base image and try to align red and blue channel with it. I found that NCC provides a better alignment overall compared to SSD.
</p>
<center><img src="./vanilla/Image_pyramid.png" align="middle"></center>
<a href="https://en.wikipedia.org/wiki/Pyramid_(image_processing)">Image source</a>
<br><br>

<hr>
<br>

<table align=center>
    <center><h1>Bells & Whistles</h1></center>
    <tr>
        <h4> Edge detector alignment</h4>
        While vanilla NCC does a decent job at matching most of the images, they fail to make good alignments if the brightness of different channels are too significant. Therefore, a better way to extract features of an image is through the use of an edge detecting filter. 
        I preprocessed each image using Sobel edge detection filter and then ran the alignment algorithm, which produced noticeable improvement for the photo for Emir of Bukhara.
    </tr>
    <table style="text-align: center;font-weight: bold;">
        <tr>
            <td><img src="vanilla/emir.jpg">Regular Implementation</td>
            <td><img src="sobel/emir.jpg">Implemented w/ Edge Detector</td>
        </tr>
    </table>
    <tr>
        <h4> Auto-constrasting</h4>
        I implemented auto-constrasting using histogram equalization functionality at scikit-image, which brought visible improvements in contrast for images with natural lighting by balancing the light distribution, although it also shows some imperfections of the images themselves. Some examples are shown below:
        <table style="text-align: center;font-weight: bold;">
            <tr><th>Only Sobel Filtering</th><th>Sobel + Auto-Constrasting</th></tr>
            <tr>
                <tr><td colspan="2">Tobolsk</td></tr>
                <tr><td><img src="sobel/tobolsk.jpg"></td><td><img src="Contrast/tobolsk.jpg"></td></tr> <!--DONE-->
                <tr><td colspan="2">Monastery</td></tr>
                <tr><td><img src="sobel/monastery.jpg"></td><td><img src="Contrast/monastery.jpg"></td></tr> <!--DONE-->
                <tr><td colspan="2">Church</td></tr>
                <tr><td><img src="sobel/church.jpg"></td><td><img src="Contrast/church.jpg"></td></tr> <!--DONE-->
            </tr>
            <tr><th>Only Sobel Filtering</th><th>Sobel + Auto-Constrasting</th></tr>
        </table>
    </tr>
</table>


<table align=center>
    <center><h1 id="viz">Results and Visualization</h1></center>
</table>
<p>
   Here are the results of the algorithm, with the optimal offset shown below each image
</p>
<table style="text-align: center;font-weight: bold;">
    <tr><th>Vanilla Filtering</th><th>Sobel + Auto-Constrasting</th></tr>
    <tr><td colspan="2">melons.jpg</td></tr>
<tr><td><img src="vanilla/melons.jpg"> R[178, 13] G[82, 10]</td><td><img src="Contrast/melons.jpg">R[177, 13] G[80, 10]</td></tr> <!--DONE-->
<tr><td colspan="2">three_generations.jpg</td></tr>
<tr><td><img src="vanilla/three_generations.jpg"> R[112, 11] G[53, 14]</td><td><img src="Contrast/three_generations.jpg">R[111, 9] G[54, 12]</td></tr> <!--DONE-->
<tr><td colspan="2">train.jpg</td></tr>
<tr><td><img src="vanilla/train.jpg"> R[87, 32] G[42, 6]</td><td><img src="Contrast/train.jpg">R[86, 31] G[42, 2]</td></tr> <!--DONE-->
<tr><td colspan="2">cathedral.jpg</td></tr>
<tr><td><img src="vanilla/cathedral.jpg"> R[12, 3] G[5, 2]</td><td><img src="Contrast/cathedral.jpg">R[12, 3] G[5, 2]</td></tr> <!--DONE-->
<tr><td colspan="2">church.jpg</td></tr>
<tr><td><img src="vanilla/church.jpg"> R[58, -4] G[25, 4]</td><td><img src="Contrast/church.jpg">R[58, -4] G[25, 4]</td></tr> <!--DONE-->
<tr><td colspan="2">onion_church.jpg</td></tr>
<tr><td><img src="vanilla/onion_church.jpg"> R[108, 36] G[52, 26]</td><td><img src="Contrast/onion_church.jpg">R[107, 35] G[51, 26]</td></tr> <!--DONE-->
<tr><td colspan="2">harvesters.jpg</td></tr>
<tr><td><img src="vanilla/harvesters.jpg"> R[124, 14] G[60, 17]</td><td><img src="Contrast/harvesters.jpg">R[124, 14] G[60, 17]</td></tr> <!--DONE-->
<tr><td colspan="2">sculpture.jpg</td></tr>
<tr><td><img src="vanilla/sculpture.jpg"> R[140, -27] G[33, -11]</td><td><img src="Contrast/sculpture.jpg">R[140, 26] G[33, -11]</td></tr> <!--DONE-->
<tr><td colspan="2">lady.jpg</td></tr>
<tr><td><img src="vanilla/lady.jpg"> R[112, 12] G[52, 9]</td><td><img src="Contrast/lady.jpg">R[119, 13] G[56, 9]</td></tr> <!--DONE-->
<tr><td colspan="2">icon.jpg</td></tr>
<tr><td><img src="vanilla/icon.jpg"> R[90, 23] G[42, 17]</td><td><img src="Contrast/icon.jpg">R[90, 23] G[42, 17]</td></tr> <!--DONE-->
<tr><td colspan="2">self_portrait.jpg</td></tr>
<tr><td><img src="vanilla/self_portrait.jpg"> R[176, 37] G[79, 29]</td><td><img src="Contrast/self_portrait.jpg">R[176, 37] G[78, 29]</td></tr> <!--DONE-->
<tr><td colspan="2">tobolsk.jpg</td></tr>
<tr><td><img src="vanilla/tobolsk.jpg"> R[6, 3] G[3, 3]</td><td><img src="Contrast/tobolsk.jpg">R[6, 3] G[3, 3]</td></tr> <!--DONE-->
<tr><td colspan="2">emir.jpg</td></tr>
<tr><td><img src="vanilla/emir.jpg"> R[98, -461] G[49, 24]</td><td><img src="Contrast/emir.jpg">R[107, 40] G[49, 24]</td></tr> <!--DONE-->
<tr><td colspan="2">monastery.jpg</td></tr>
<tr><td><img src="vanilla/monastery.jpg"> R[-3, 2] G[3, 2]</td><td><img src="Contrast/monastery.jpg">R[-3, 2] G[3, 2]</td></tr> <!--DONE-->
</table>

  <br><br>
  <p>For intermediate results with just Sobel filters, please refer to /sobel/ in the zipped folder.</p>
<hr>
<br>



<table align=center style="margin-bottom: 50px">
    <tr>
        <td>
            <left>
                <center><h1>Acknowledgements</h1></center>
This project is a course project for CS 180. Part of the code is provided by course staff. Website template is referenced from Shufan Li in Fall 2022 iteration of the class
</left>
        </td>
    </tr>
</table>


</body>
</html>
